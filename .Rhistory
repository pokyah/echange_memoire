a$output$condition$message
stations.df
devtools::load_all()
View(stations.df)
stations = typeData(meta_and_records.l = getData(dfrom = "2018-01-01T00:00:00Z", dto = "2018-01-01T00:01:00Z"), table_name = "cleandata")
stations = typeData(meta_and_records.l = getData(dfrom = "2018-01-01T00:00:00Z", dto = "2018-01-01T00:01:00Z"), table_name = "cleandata")
Sys.getenv("AGROMET_API_V1_KEY")
Sys.getenv()
stations = typeData(meta_and_records.l = getData(dfrom = "2018-01-01T00:00:00Z", dto = "2018-01-01T00:01:00Z"), table_name = "cleandata")
devtools::load_all()
stations = typeData(meta_and_records.l = getData(dfrom = "2018-01-01T00:00:00Z", dto = "2018-01-01T00:01:00Z"), table_name = "cleandata")
stations = typeData(meta_and_records.l = getData(dfrom = "2018-01-01T00:00:00Z", dto = "2018-01-01T00:01:00Z"), table_name = "cleandata")
stations = typeData(meta_and_records.l = getData(dfrom = "2018-01-01T00:00:00Z", dto = "2018-01-01T00:01:00Z"), table_name = "cleandata")
devtools::load_all()
stations = typeData(meta_and_records.l = getData(dfrom = "2018-01-01T00:00:00Z", dto = "2018-01-01T00:01:00Z"), table_name = "cleandata")
install.packages("elevatr")
library(tidyverse)
library(lubridate)
library(rgdal)
library(rgeos)
library(dplyr)
library(sf)
library(raster)
library(rnaturalearth)
library(rnaturalearthhires)
library(jsonlite)
library(elevatr)
source("./R/agrometAPI.R")
library(tidyverse)
library(lubridate)
library(rgdal)
library(rgeos)
library(dplyr)
library(sf)
library(raster)
library(rnaturalearth)
library(rnaturalearthhires)
library(jsonlite)
library(elevatr)
source("./R/agrometAPI.R")
#####
## ADMIN BOUNDARIES
# loading wallonia boundaries from local geojson file created by JP huart and removing all attributes
wallonia = sf::st_read(dsn = "./data-raw/extdata/AGROMET/wallonie.geojson")
wallonia = wallonia[,-(1:length(wallonia))]
#####
## DEM
# downloading the raster tile data using elevatr
# for resolution corresponding to z parameter check elevatr doc https://cran.r-project.org/web/packages/elevatr/vignettes/introduction_to_elevatr.html#get_raster_elevation_data
# 9 is around 200 m resolution at 45Â° lat
DEM = elevatr::get_elev_raster(
as(
sf::st_transform(
sf::st_buffer(sf::st_transform(wallonia, 3812), 20000),
4326),
"Spatial"),
z = 9,
src = "aws")
# cliping to bbox of Wallonia + 5km buffer
DEM = raster::mask(DEM,
as(
sf::st_transform(
sf::st_buffer(sf::st_transform(wallonia, 3812), 20000),
4326),
"Spatial"))
elevation = DEM
# computing slope and aspect
slope = raster::terrain(DEM, "slope")
aspect = raster::terrain(DEM, "aspect")
#####
## CORINE LAND COVER
# # Download CORINE land cover for Belgium from http://inspire.ngi.be/download-free/atomfeeds/AtomFeed-en.xml
# # read the downlaoded .shp
# corine <- sf::st_read("./data-raw/extdata/CLC/CLC12_BE.shp")
# # project to 4326
# corine = sf::st_transform(corine, 4326)
# # crop to Wallonia + 5 km buffer
# corine = sf::st_intersection(sf::st_transform(corine, 3812), sf::st_buffer(sf::st_transform(wallonia, 3812), 5000))
# # Download legend for CLC
# download.file("http://www.eea.europa.eu/data-and-maps/data/corine-land-cover-2006-raster-1/corine-land-cover-classes-and/clc_legend.csv/at_download/file",
#   destfile = "./data-raw/extdata/CLC/clc_legend.csv")
# corine.lgd = read.csv(file = "./data-raw/extdata/CLC/clc_legend.csv", header = TRUE, sep = ",")
# corine.lgd$CLC_CODE = as.numeric(corine.lgd$CLC_CODE)
# # Legend codes present in Wallonia
# lgd.codes = data.frame(unique(corine$code_12))
# colnames(lgd.codes) = "CLC_CODE"
# lgd.codes$CLC_CODE = as.numeric(as.character(lgd.codes$CLC_CODE))
# # Legend for CLC in Wallonia
# wal.lgd = corine.lgd %>%
#   dplyr::filter(CLC_CODE %in% lgd.codes$CLC_CODE)
# # Reclass all types of CLC to create 6 groups
# corine$code_12 = as.numeric(as.character(corine$code_12))
# corine = corine %>%
#   dplyr::mutate(
#     custom.class = dplyr::case_when(
#       code_12 <= 142 ~ "Artificials surfaces",
#       code_12 == 211 ~ "Agricultural areas",
#       code_12 == 222 ~ "Agricultural areas",
#       code_12 == 231 ~ "Herbaceous vegetation",
#       code_12 == 242 ~ "Agricultural areas",
#       code_12 == 243 ~ "Agricultural areas",
#       code_12 == 311 ~ "Forest",
#       code_12 == 312 ~ "Forest",
#       code_12 == 313 ~ "Forest",
#       code_12 == 321 ~ "Herbaceous vegetation",
#       code_12 == 322 ~ "Herbaceous vegetation",
#       code_12 == 324 ~ "Forest",
#       code_12 > 400 ~ "Water")
#   )
# corine = sf::st_transform(corine, 4326)
#####
## RMI INCA GRID
# load the INCAgrid + buffer 5km built from january 2019 RMI data (with AGROMET px refs by jphuart)
incaGrid_pxAg = sf::st_read("./data-raw/extdata/AGROMET/agromet_inca_grid_buf_5km.geojson")
# rename
incaGrid = incaGrid_pxAg
#####
## INCA GRID EXTRACTIONS : DEM
# extracting DEM
inca.elevation.ext <- raster::extract(
raster::projectRaster(
DEM,
crs = (sf::st_crs(incaGrid))$proj4string
),
as(incaGrid, "Spatial"),
buffer = 500, # the buffer on which calculate the mean elevation around grid centroids
fun = mean,
na.rm = TRUE,
df = TRUE
)
# rename column layer to elevation
colnames(inca.elevation.ext) = c("ID", "elevation")
# extracting slope
inca.slope.ext <- raster::extract(
raster::projectRaster(
slope,
crs = (sf::st_crs(incaGrid))$proj4string
),
as(incaGrid, "Spatial"),
buffer = 500,
fun = mean,
na.rm = TRUE,
df = TRUE
)
# extracting aspect
inca.aspect.ext <- raster::extract(
raster::projectRaster(
aspect,
crs = (sf::st_crs(incaGrid))$proj4string
),
as(incaGrid, "Spatial"),
buffer = 500,
fun = mean,
na.rm = TRUE,
df = TRUE
)
# storing in a sf object
inca.ext = bind_cols(incaGrid, inca.elevation.ext, inca.slope.ext, inca.aspect.ext)
# static independent vars at grid points + grid points geography objects
grid.sf = inca.ext
# adding lat/lon data from from grid.sf to grid & limiting to Wallonia without buffer
grid.sf = sf::st_intersection(sf::st_transform(grid.sf, 3812), sf::st_transform(wallonia, 3812))
grid.df = grid.sf
grid.sf = grid.sf %>%
dplyr::select(c(px))
grid.df = grid.df %>%
dplyr::select(c(px, elevation, slope, aspect, Agricultural_areas, Artificials_surfaces, Forest, Herbaceous_vegetation))
grid.df = grid.df %>%
dplyr::left_join(
(data.frame(st_coordinates(st_transform(grid.sf, 3812))) %>%
dplyr::bind_cols(grid.sf["px"]) %>%
dplyr::select(-geometry)
),
by = "px"
)
sf::st_geometry(grid.df) = NULL
# exporting the grid to geojson file
grid.data.sf = grid.sf %>% left_join(grid.df, by = "px")
sf::st_write(grid.data.sf, dsn = "./data-raw/grid.geojson", driver = "GeoJSON")
# the points grid as square polygons for map rendering
grid.squares.sf = sf::st_make_grid(
x = grid.sf, cellsize = 1000, what = "polygons",
offset = c(min(grid.df$X), min(grid.df$Y)))
grid.squares.sf = sf::st_intersection(sf::st_transform(grid.squares.sf, 3812), sf::st_transform(wallonia, 3812))
grid.squares.sf = sf::st_join(sf::st_transform(sf::st_sf(grid.squares.sf), 3812), sf::st_transform(grid.sf, 3812))
grid.squares.sf = na.omit(grid.squares.sf)
#####
## SAVING ALL THE GRID + WALLONIA OBJECTS TO PACKAGE DATA
# doc : http://r-pkgs.had.co.nz/data.html
# saving in ./data/*.rda
devtools::use_data(wallonia, grid.sf, grid.df, grid.squares.sf, internal = FALSE, overwrite = TRUE)
stations = getData(table_name = "station")$stations_meta.df
stations = stations %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(c("sid", "poste", "longitude", "latitude", "network_name", "type_name"))
stations = sf::st_as_sf(stations, coords = c("longitude", "latitude"))
stations = sf::st_set_crs(stations, 4326)
head(stations)
class(stations)
View(stations)
stations.df = getData(table_name = "station")$stations_meta.df
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(c("sid", "poste", "longitude", "latitude", "network_name", "type_name"))
head(stations.df)
stations.sf = sf::st_as_sf(stations.df, coords = c("longitude", "latitude"))
stations.sf = sf::st_set_crs(stations, 4326)
head(stations.sf)
stations.sf = sf::st_as_sf(stations.df, coords = c("longitude", "latitude"))
head(stations.sf)
View(stations.df)
stations.df = getData(table_name = "station")$stations_meta.df
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(c("sid", "poste", "longitude", "latitude", "network_name", "type_name"))
stations.sf = sf::st_as_sf(stations.df, coords = c("longitude", "latitude"))
plot(stations.sf)
library(sf)
stations.df = getData(table_name = "station")$stations_meta.df
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(c("sid", "poste", "longitude", "latitude", "network_name", "type_name"))
head(stations.df)
stations.sf = sf::st_as_sf(stations.df, coords = c("longitude", "latitude"))
View(stations.sf)
stations.df = getData(table_name = "station")$stations_meta.df
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(c("sid", "poste", "longitude", "latitude", "network_name", "type_name"))
stations.df = getData(table_name = "station")$stations_meta.df
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(c("sid", "poste", "longitude", "latitude", "network_name", "type_name")) %>%
dplyr::mutate_at(dplyr::vars(dplyr::one_of(c(sensors, "altitude", "latitude", "longitude", "sid"))), dplyr::funs(as.numeric)))
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(c("sid", "poste", "longitude", "latitude", "network_name", "type_name")) %>%
dplyr::mutate_at(
dplyr::vars(dplyr::one_of(c(sensors, "altitude", "latitude", "longitude", "sid"))), dplyr::funs(as.numeric))
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(c("sid", "poste", "longitude", "latitude", "network_name", "type_name")) %>%
dplyr::mutate_at(
dplyr::vars(dplyr::one_of(c("altitude", "latitude", "longitude", "sid"))), dplyr::funs(as.numeric))
stations.sf = sf::st_as_sf(stations.df, coords = c("longitude", "latitude"))
stations.sf = sf::st_set_crs(stations, 4326)
head(stations.sf)
stations.df = getData(table_name = "station")$stations_meta.df
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::mutate_at(
dplyr::vars(dplyr::one_of(c("altitude", "latitude", "longitude", "sid"))), dplyr::funs(as.numeric))
class(stations.df$longitude)
class(stations.df$latitude)
stations.sf = sf::st_as_sf(stations.df, coords = c("longitude", "latitude"))
plot(stations.sf)
colnames(stations.df)
stations.df = getData(table_name = "station")$stations_meta.df
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(one_of(c("altitude", "latitude", "longitude", "sid", "poste"))) %>%
dplyr::mutate_at(
dplyr::vars(dplyr::one_of(c("altitude", "latitude", "longitude", "sid"))), dplyr::funs(as.numeric))
stations.sf = sf::st_as_sf(stations.df, coords = c("longitude", "latitude"))
stations.sf
stations.sf = sf::st_set_crs(stations, 4326)
plot(stations.sf)
stations.df
class(stations.df$altitude)
class(stations.df$latitude)
class(stations.df$longitude)
stations.sf = sf::st_as_sf(stations.df, coords = c("longitude", "latitude"))
stations.sf
View(stations.sf)
plot(stations.sf)
stations.sf = sf::st_set_crs(stations, 4326)
plot(stations.sf)
stations.sf = sf::st_set_crs(stations.sf, 4326)
plot(stations.sf)
stations.df = getData(table_name = "station")$stations_meta.df
stations.df = stations.df %>%
dplyr::filter(network_name == "pameseb" | network_name == "irm") %>%
dplyr::filter(type_name != "Sencrop") %>%
dplyr::filter(state == "Ok") %>%
dplyr::select(one_of(c("altitude", "latitude", "longitude", "sid", "poste"))) %>%
dplyr::mutate_at(
dplyr::vars(dplyr::one_of(c("altitude", "latitude", "longitude", "sid"))), dplyr::funs(as.numeric))
stations.sf = sf::st_as_sf(stations.df, coords = c("longitude", "latitude"))
stations.sf = sf::st_set_crs(stations.sf, 4326)
stations.df = getData(table_name = "station")$stations_meta.df
devtools::load_all()
tasks = lapply(ex_makeTasks, `[[`, 1)
tasks$`20160204150000`
bmr = makeBatchOfBenchExp(
tasks = tasks,
learners = list(
learners$baseLearners$lrn.lm.alt,
learners$baseLearners$lrn.gstat.idw,
learners$baseLearners$lrn.gstat.krige,
learners$baseLearners$lrn.gstat.krige.alt,
learners$baseLearners$lrn.gstat.1nn
),
measures = list(rmse, mae, mse),
keep.pred = TRUE,
models = TRUE,
grouping = 1000,
level = "mlr.benchmark",
resamplings = "LOO",
cpus = 4,
prefix = "test_april_1_",
output_dir = "bmrs",
removeTemp = FALSE
)
library(mlr)
bmr = makeBatchOfBenchExp(
tasks = tasks,
learners = list(
learners$baseLearners$lrn.lm.alt,
learners$baseLearners$lrn.gstat.idw,
learners$baseLearners$lrn.gstat.krige,
learners$baseLearners$lrn.gstat.krige.alt,
learners$baseLearners$lrn.gstat.1nn
),
measures = list(rmse, mae, mse),
keep.pred = TRUE,
models = TRUE,
grouping = 1000,
level = "mlr.benchmark",
resamplings = "LOO",
cpus = 4,
prefix = "test_april_1_",
output_dir = "bmrs",
removeTemp = FALSE
)
paste0("./", output_dir,
"/",
prefix,
"_bmr_",
mlr::getTaskId(tasks[[tasks.groups.start[x]]]),
"_",
mlr::getTaskId(tasks[[tasks.groups.end[x]]]),
".rds")
bmr$output$value$perfs
bmr$output$value$perfs
bmr$output$value$aggPerfs
bmr$output$value$summary
devtools::load_all()
bmr = makeBatchOfBenchExp(
tasks = tasks,
learners = list(
learners$baseLearners$lrn.lm.alt,
learners$baseLearners$lrn.gstat.idw,
learners$baseLearners$lrn.gstat.krige,
learners$baseLearners$lrn.gstat.krige.alt,
learners$baseLearners$lrn.gstat.1nn
),
measures = list(rmse, mae, mse),
keep.pred = TRUE,
models = TRUE,
grouping = 1000,
level = "mlr.benchmark",
resamplings = "LOO",
cpus = 4,
prefix = "test_april_1_",
output_dir = "bmrs/test/",
removeTemp = FALSE
)
bmr = makeBatchOfBenchExp(
tasks = tasks,
learners = list(
learners$baseLearners$lrn.lm.alt,
learners$baseLearners$lrn.gstat.idw,
learners$baseLearners$lrn.gstat.krige,
learners$baseLearners$lrn.gstat.krige.alt,
learners$baseLearners$lrn.gstat.1nn
),
measures = list(rmse, mae, mse),
keep.pred = TRUE,
models = TRUE,
grouping = 1000,
level = "mlr.benchmark",
resamplings = "LOO",
cpus = 4,
prefix = "test_april_1_",
output_dir = "bmrs/test/testa",
removeTemp = FALSE
)
bmr = makeBatchOfBenchExp(
tasks = tasks,
learners = list(
learners$baseLearners$lrn.lm.alt,
learners$baseLearners$lrn.gstat.idw,
learners$baseLearners$lrn.gstat.krige,
learners$baseLearners$lrn.gstat.krige.alt,
learners$baseLearners$lrn.gstat.1nn
),
measures = list(rmse, mae, mse),
keep.pred = TRUE,
models = TRUE,
grouping = 1000,
level = "mlr.benchmark",
resamplings = "LOO",
cpus = 4,
prefix = "test_april_1_",
output_dir = "./bmrs/test/testa",
removeTemp = FALSE
)
!dir.exists(output_dir)
devtools::load_all()
bmr = makeBatchOfBenchExp(
tasks = tasks,
learners = list(
learners$baseLearners$lrn.lm.alt,
learners$baseLearners$lrn.gstat.idw,
learners$baseLearners$lrn.gstat.krige,
learners$baseLearners$lrn.gstat.krige.alt,
learners$baseLearners$lrn.gstat.1nn
),
measures = list(rmse, mae, mse),
keep.pred = TRUE,
models = TRUE,
grouping = 1000,
level = "mlr.benchmark",
resamplings = "LOO",
cpus = 4,
prefix = "test_april_1_",
output_dir = "./bmrs/test/testa",
removeTemp = FALSE
)
devtools::load_all()
bmr = makeBatchOfBenchExp(
tasks = tasks,
learners = list(
learners$baseLearners$lrn.lm.alt,
learners$baseLearners$lrn.gstat.idw,
learners$baseLearners$lrn.gstat.krige,
learners$baseLearners$lrn.gstat.krige.alt,
learners$baseLearners$lrn.gstat.1nn
),
measures = list(rmse, mae, mse),
keep.pred = TRUE,
models = TRUE,
grouping = 1000,
level = "mlr.benchmark",
resamplings = "LOO",
cpus = 4,
prefix = "test_april_1_",
output_dir = "./bmrs/test/testa",
removeTemp = FALSE
)
bmr = makeBatchOfBenchExp(
tasks = tasks,
learners = list(
learners$baseLearners$lrn.lm.alt,
learners$baseLearners$lrn.gstat.idw,
learners$baseLearners$lrn.gstat.krige,
learners$baseLearners$lrn.gstat.krige.alt,
learners$baseLearners$lrn.gstat.1nn
),
measures = list(rmse, mae, mse),
keep.pred = TRUE,
models = TRUE,
grouping = 1000,
level = "mlr.benchmark",
resamplings = "LOO",
cpus = 4,
prefix = "test_april_1_",
output_dir = "./bmrs/testb/",
removeTemp = FALSE
)
bmr$output$condition$message
bmr = makeBatchOfBenchExp(
tasks = tasks,
learners = list(
learners$baseLearners$lrn.lm.alt,
learners$baseLearners$lrn.gstat.idw,
learners$baseLearners$lrn.gstat.krige,
learners$baseLearners$lrn.gstat.krige.alt,
learners$baseLearners$lrn.gstat.1nn
),
measures = list(rmse, mae, mse),
keep.pred = TRUE,
models = TRUE,
grouping = 1000,
level = "mlr.benchmark",
resamplings = "LOO",
cpus = 4,
prefix = "test_april_1_",
output_dir = "~/Desktop/",
removeTemp = FALSE
)
packrat::on()
